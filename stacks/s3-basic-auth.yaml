AWSTemplateFormatVersion: 2010-09-09
Description: HTTP Basic Authentication for S3 buckets

Parameters:
  OriginBucketName:
    Type: String
    Description: The name of the bucket to which authenticated access should be provided to.

  AuthorizationCredentials:
    Type: String
    Description: |
      Base64 encoded representation of valid ${username}:${password} authorization
      header. This value will be hard-coded to the Lambda function code which means
      anyone with access to Lambda is able to get access to the credentials. For
      example, username=sami, password=p4s5w0rd! would result to AuthorizationCredentials
      value of c2FtaTpwNHM1dzByZCE=
    NoEcho: true

  UpdateTime:
    Type: String
    Description: |
      The time this update started. This is needed to ensure that an update to the
      autopublish lambda is triggered and executed every time the stack changes.

  UtilityLogRetention:
    Type: Number
    Description: The number of days to retain logs generated by utility functions.
    Default: '1'

Resources:

  ## CloudFront distribution and related configuration ##

  Distribution:
    Type: 'AWS::CloudFront::Distribution'
    Properties:
      DistributionConfig:
        DefaultCacheBehavior:
          ForwardedValues:
            QueryString: 'false'
            Cookies: { Forward: none }
          LambdaFunctionAssociations:
            - EventType: 'viewer-request'
              LambdaFunctionARN: !GetAtt AuthenticatorLambdaAutopublish.LatestVersionArn
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
        Enabled: 'true'
        HttpVersion: http2
        Origins:
          - DomainName: !Sub '${OriginBucketName}.s3.amazonaws.com'
            Id: S3Origin
            S3OriginConfig:
              OriginAccessIdentity: !Sub 'origin-access-identity/cloudfront/${DistributionOriginAccessIdentity}'
        PriceClass: PriceClass_All
        ViewerCertificate:
          CloudFrontDefaultCertificate: 'true'

  DistributionOriginAccessIdentity:
    Type: AWS::CloudFront::CloudFrontOriginAccessIdentity
    Properties:
      CloudFrontOriginAccessIdentityConfig:
        Comment: !Sub ${AWS::StackName}

  BucketPolicyForDistribution:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref OriginBucketName
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowReadsThroughCloudFront
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::cloudfront:user/CloudFront Origin Access Identity ${DistributionOriginAccessIdentity}'
            Action: s3:GetObject
            Resource: !Sub 'arn:aws:s3:::${OriginBucketName}/*'

  ## Lambda function for performing HTTP Basic Auth at the edge ##

  AuthenticatorLambda:
    Type: AWS::Lambda::Function
    DeletionPolicy: Retain # replicated functions cannot be deleted
    Properties:
      Code:
        ZipFile: !Sub |
          'use strict'

          const CORRECT_AUTH = 'Basic ${AuthorizationCredentials}'

          exports.handler = (event, context, callback) => {
            const request = event.Records[0].cf.request
            if (!request.headers.authorization || request.headers.authorization.length === 0) {
              // No header present. Send auth request.
              return callback(null, {
                status: '401',
                statusDescription: 'Unauthorized',
                headers: {
                  'www-authenticate': [{
                    key: 'WWW-Authenticate',
                    value: 'Basic realm="Restricted Access"'
                  }]
                }
              })
            }

            const auth = request.headers.authorization[0].value
            if (auth === CORRECT_AUTH) {
              // Authentication was correct. Continue with the request
              return callback(null, request)
            }

            // Wrong username / password; deny access
            return callback(null, {
              status: '403',
              statusDescription: 'Forbidden'
            })
          }
      Handler: index.handler
      Role: !GetAtt AuthenticatorLambdaRole.Arn
      Runtime: 'nodejs10.x'
      Timeout: '1' # as per lambda@edge limits

  AuthenticatorLambdaAutopublish:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt CustomPublishFunctionLambda.Arn
      FunctionName: !Ref AuthenticatorLambda
      UpdateTime: !Ref UpdateTime # Changes everytime to ensure we get executed

  AuthenticatorLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
                - edgelambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: AllowWritesToCloudWatchLogs
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*

  AuthenticatorLambdaLogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      LogGroupName: !Sub '/aws/lambda/${AuthenticatorLambda}'
      RetentionInDays: 1

  ## Resources for automatically publishing a new version of a Lambda function on code change ##

  CustomPublishFunctionLambda:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: |
          import boto3
          import cfnresponse

          client = boto3.client('lambda')

          def handler(event, context):
              print('Received request', event)
              properties = event['ResourceProperties']
              phyid = event.get('PhysicalResourceId', '%s/%s' % (event['StackId'], event['LogicalResourceId']))
              if 'FunctionName' not in properties:
                  print('ERROR: FunctionName missing')
                  return cfnresponse.send(event, context, cfnresponse.FAILED, {}, phyid)

              if event['RequestType'] in ('Create', 'Update'):
                  latest = None
                  latest_version = 0
                  latest_published = None
                  while True:
                      res = client.list_versions_by_function(FunctionName=properties['FunctionName'])

                      for version in res['Versions']:
                          if version['Version'] == '$LATEST':
                              latest = version
                          elif int(version['Version']) > latest_version:
                              latest_version = int(version['Version'])
                              latest_published = version

                      if 'NextMarker' not in res:
                          print('DEBUG: Found all versions')
                          break

                  if latest_published and latest['CodeSha256'] == latest_published['CodeSha256']:
                      # No code changes. Don't publish
                      print('DEBUG: No changes since last update')
                      return cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'LatestVersion': latest_published['Version'],
                          'LatestVersionArn': latest_published['FunctionArn']
                      }, phyid)

                  # Some changes made. Publish a new version
                  res = client.publish_version(FunctionName=properties['FunctionName'])

                  return cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'LatestVersion': res['Version'],
                      'LatestVersionArn': res['FunctionArn']
                  }, phyid)

              elif event['RequestType'] == 'Delete':
                  return cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, phyid)

      Handler: index.handler
      Role: !GetAtt CustomPublishFunctionLambdaRole.Arn
      Runtime: 'python3.7'
      Timeout: '120'

  CustomPublishFunctionLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        -
          PolicyName: AllowWritesToCloudWatchLogs
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              -
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
        -
          PolicyName: AllowPublishLambdaFunction
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              -
                Effect: Allow
                Action:
                  - lambda:ListVersionsByFunction
                  - lambda:PublishVersion
                Resource:
                  - '*'

  CustomPublishFunctionLambdaLogGroup:
    Type: "AWS::Logs::LogGroup"
    Properties:
      LogGroupName: !Sub '/aws/lambda/${CustomPublishFunctionLambda}'
      RetentionInDays: !Ref UtilityLogRetention

Outputs:
  DistributionDomainName:
    Description: The domain name for the CloudFront distribution
    Value: !GetAtt Distribution.DomainName

  DistributionId:
    Description: The ID of the example CloudFront distribution
    Value: !Ref Distribution

  DistributionOaiId:
    Description: The ID of the origin access identity used to access the S3 bucket
    Value: !Ref DistributionOriginAccessIdentity
